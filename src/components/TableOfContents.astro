---
export interface Props {
  content?: string;
}
---

<!-- Desktop TOC Sidebar -->
<div class="toc-wrapper" id="toc-wrapper">
  <div class="toc-header">
    <span class="toc-title">Contents</span>
    <button class="toc-toggle" id="toc-toggle" aria-label="Toggle table of contents" aria-expanded="true">
      <i class="toc-icon"></i>
    </button>
  </div>
  <nav class="toc" id="toc">
    <ul class="toc-list"></ul>
    <div class="toc-empty-message" id="toc-empty-message" style="display: none;">
      <p>No headings found in this page.</p>
      <p class="toc-empty-hint">Add h2 or h3 headings to generate a table of contents.</p>
    </div>
  </nav>
</div>

<!-- Mobile/Tablet TOC Button (top bar) -->
<button class="toc-top-btn" id="toc-top-btn" aria-label="Open table of contents">
  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <line x1="8" y1="6" x2="21" y2="6"></line>
    <line x1="8" y1="12" x2="21" y2="12"></line>
    <line x1="8" y1="18" x2="21" y2="18"></line>
    <line x1="3" y1="6" x2="3.01" y2="6"></line>
    <line x1="3" y1="12" x2="3.01" y2="12"></line>
    <line x1="3" y1="18" x2="3.01" y2="18"></line>
  </svg>
  <span class="toc-top-btn-text">Contents</span>
</button>

<!-- Mobile TOC Drawer/Modal -->
<div class="toc-mobile-overlay" id="toc-mobile-overlay">
  <div class="toc-mobile-drawer" id="toc-mobile-drawer">
    <div class="toc-mobile-header">
      <span class="toc-mobile-title">Contents</span>
      <button class="toc-mobile-close" id="toc-mobile-close" aria-label="Close table of contents">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <nav class="toc-mobile-content" id="toc-mobile-content">
      <ul class="toc-list"></ul>
    </nav>
  </div>
</div>

<style>
  .toc-wrapper {
    position: sticky;
    top: 2rem;
    max-height: calc(100vh - 4rem);
    overflow-y: auto;
    padding: 1.5rem;
    background: var(--card-bg, rgba(17, 17, 17, 0.85));
    border: 1px solid var(--border-color, #222);
    border-radius: 12px;
    font-family: 'Poppins', sans-serif;
    z-index: 100; /* Higher z-index to appear in foreground */
  }

  .toc-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--border-color, #222);
  }

  .toc-title {
    font-size: 0.9rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--accent-color, #d4b78c);
  }

  .toc-toggle {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    color: var(--accent-color, #d4b78c);
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
    line-height: 1;
  }

  .toc-toggle:hover {
    opacity: 0.8;
  }

  .toc-toggle[aria-expanded="false"] {
    transform: rotate(-90deg);
  }

  .toc-icon {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 6px solid currentColor;
    transition: transform 0.3s ease;
  }

  .toc-wrapper.collapsed .toc-icon {
    transform: rotate(180deg);
  }

  .toc {
    display: block;
    transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s ease, margin 0.35s ease, padding 0.35s ease;
    max-height: 2000px;
    opacity: 1;
    overflow: hidden;
    margin-top: 0;
    padding-top: 0;
  }

  .toc-wrapper.collapsed .toc {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    margin-bottom: 0;
    padding-top: 0;
    padding-bottom: 0;
  }

  .toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .toc-empty-message {
    padding: 1.5rem 0;
    text-align: center;
    color: var(--text-muted, rgba(230, 224, 214, 0.6));
  }

  .toc-empty-message p {
    margin: 0.5rem 0;
    font-size: 0.85rem;
    line-height: 1.5;
  }

  .toc-empty-message .toc-empty-hint {
    font-size: 0.75rem;
    color: var(--text-muted, rgba(230, 224, 214, 0.5));
    font-style: italic;
  }

  .toc-item {
    margin: 0;
    padding: 0;
    position: relative;
  }

  .toc-item.toc-level-2 {
    margin-bottom: 0.5rem;
  }

  .toc-item.toc-level-2.has-children {
    position: relative;
  }

  .toc-item.toc-level-2 > .toc-link {
    text-align: left;
  }

  .toc-sublist {
    list-style: none;
    padding: 0 !important;
    margin: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    overflow: hidden;
    transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                opacity 0.25s ease;
    max-height: 2000px;
    opacity: 1;
  }

  .toc-item.toc-level-2.collapsed .toc-sublist {
    max-height: 0 !important;
    opacity: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    padding: 0 !important;
    overflow: hidden !important;
    visibility: hidden !important;
    pointer-events: none !important;
    height: 0 !important;
    min-height: 0 !important;
    line-height: 0 !important;
    font-size: 0 !important;
    border: none !important;
    box-sizing: border-box !important;
  }
  
  .toc-item.toc-level-2:not(.collapsed) .toc-sublist {
    visibility: visible;
    pointer-events: auto;
  }
  
  .toc-item.toc-level-2.collapsed .toc-item.toc-level-3 {
    height: 0 !important;
    min-height: 0 !important;
    max-height: 0 !important;
    margin: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    padding: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    overflow: hidden !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    line-height: 0 !important;
    font-size: 0 !important;
    border: none !important;
    border-left: none !important;
    box-sizing: border-box !important;
    display: block !important;
  }
  
  .toc-item.toc-level-2.collapsed .toc-item.toc-level-3 .toc-link {
    display: none !important;
    height: 0 !important;
    min-height: 0 !important;
    max-height: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    font-size: 0 !important;
    line-height: 0 !important;
    visibility: hidden !important;
    opacity: 0 !important;
    overflow: hidden !important;
    box-sizing: border-box !important;
  }
  
  .toc-item.toc-level-2.collapsed .toc-item.toc-level-3 * {
    display: none !important;
    height: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
  }

  .toc-item.toc-level-3 {
    margin-bottom: 0.15rem;
    margin-top: 0;
    padding: 0;
    padding-left: 0;
    margin-left: 0.75rem;
    border-left: 2px solid var(--border-color, #222);
    text-align: left;
    position: relative;
  }
  
  .toc-item.toc-level-3 .toc-link {
    padding-left: 0.5rem;
  }
  
  .toc-item.toc-level-3:first-child {
    margin-top: 0;
  }
  
  .toc-item.toc-level-3:last-child {
    margin-bottom: 0;
  }

  :global(.toc-link) {
    display: block;
    padding: 0.4rem 0;
    color: var(--text-muted, rgba(230, 224, 214, 0.7));
    text-decoration: none;
    font-size: 0.85rem;
    line-height: 1.5;
    border-radius: 4px;
    transition: all 0.2s ease;
    position: relative;
    box-shadow: none !important;
    text-align: left;
  }

  :global(.toc-link:hover) {
    color: var(--accent-color, #d4b78c);
    background: rgba(212, 183, 140, 0.1);
  }

  /* Active TOC link - Chirpy exact style with glow */
  :global(.toc-link.active),
  :global(a.toc-link.active) {
    color: var(--accent-color, #d4b78c) !important;
    background: rgba(212, 183, 140, 0.25) !important;
    font-weight: 600 !important;
    border-left: 3px solid var(--accent-color, #d4b78c) !important;
    padding-left: calc(0.75rem - 3px) !important;
    text-shadow: 
      0 0 10px rgba(212, 183, 140, 0.8) !important,
      0 0 5px rgba(212, 183, 140, 0.6) !important;
    box-shadow: 
      0 0 15px rgba(212, 183, 140, 0.4) !important,
      0 0 8px rgba(212, 183, 140, 0.3) !important,
      inset 0 0 10px rgba(212, 183, 140, 0.15) !important;
  }

  :global(.toc-item.toc-level-3 .toc-link.active),
  :global(.toc-item.toc-level-3 a.toc-link.active) {
    border-left: 3px solid var(--accent-color, #d4b78c) !important;
    padding-left: calc(0.75rem - 3px) !important;
    box-shadow: 
      0 0 15px rgba(212, 183, 140, 0.4) !important,
      0 0 8px rgba(212, 183, 140, 0.3) !important,
      inset 0 0 10px rgba(212, 183, 140, 0.15) !important;
  }

  .toc-wrapper::-webkit-scrollbar {
    width: 4px;
  }

  .toc-wrapper::-webkit-scrollbar-track {
    background: transparent;
  }

  .toc-wrapper::-webkit-scrollbar-thumb {
    background: rgba(212, 183, 140, 0.3);
    border-radius: 2px;
  }

  .toc-wrapper::-webkit-scrollbar-thumb:hover {
    background: rgba(212, 183, 140, 0.5);
  }

  /* Mobile/Tablet TOC Button (top bar) - Chirpy style */
  .toc-top-btn {
    display: none;
    position: fixed;
    top: 1.5rem;
    right: 1.5rem;
    z-index: 1002; /* Higher than menu button (1001) */
    background: rgba(17, 17, 17, 0.95);
    border: 1px solid var(--accent-color, #d4b78c);
    border-radius: 8px;
    padding: 0.625rem 1rem;
    color: var(--accent-color, #d4b78c);
    font-family: 'Poppins', sans-serif;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(15px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(212, 183, 140, 0.2);
    align-items: center;
    gap: 0.5rem;
    will-change: transform, opacity, box-shadow;
    white-space: nowrap;
  }

  .toc-top-btn:hover {
    background: rgba(212, 183, 140, 0.15);
    box-shadow: 0 6px 24px rgba(212, 183, 140, 0.5), 0 0 0 1px rgba(212, 183, 140, 0.4);
    transform: translateY(-2px);
  }

  .toc-top-btn:active {
    transform: translateY(0);
  }

  .toc-top-btn svg {
    width: 18px;
    height: 18px;
    flex-shrink: 0;
  }

  .toc-top-btn-text {
    display: inline;
  }

  /* Mobile TOC Drawer/Modal */
  .toc-mobile-overlay {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
    z-index: 1003; /* Higher than button */
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }

  .toc-mobile-overlay.active {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }

  .toc-mobile-drawer {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    max-width: 400px;
    background: rgba(17, 17, 17, 0.98);
    border-left: 1px solid var(--border-color, #222);
    box-shadow: -10px 0 40px rgba(0, 0, 0, 0.5);
    z-index: 1004; /* Highest - drawer should be on top */
    display: flex;
    flex-direction: column;
    transform: translateX(100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
  }

  .toc-mobile-overlay.active .toc-mobile-drawer {
    transform: translateX(0);
  }

  .toc-mobile-header {
    padding: 1.5rem;
    border-bottom: 1px solid var(--border-color, #222);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(212, 183, 140, 0.05);
    flex-shrink: 0;
  }

  .toc-mobile-title {
    font-size: 1.1rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--accent-color, #d4b78c);
    font-family: 'Poppins', sans-serif;
  }

  .toc-mobile-close {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--border-color, #2a2a2a);
    color: var(--text-muted, #999);
    font-size: 1rem;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s ease;
    line-height: 1;
  }

  .toc-mobile-close:hover {
    background: rgba(212, 183, 140, 0.1);
    border-color: var(--accent-color, #d4b78c);
    color: var(--accent-color, #d4b78c);
  }

  .toc-mobile-content {
    padding: 1.5rem;
    overflow-y: auto;
    flex: 1;
    scrollbar-width: thin;
    scrollbar-color: rgba(212, 183, 140, 0.3) transparent;
  }

  .toc-mobile-content::-webkit-scrollbar {
    width: 6px;
  }

  .toc-mobile-content::-webkit-scrollbar-track {
    background: transparent;
  }

  .toc-mobile-content::-webkit-scrollbar-thumb {
    background: rgba(212, 183, 140, 0.3);
    border-radius: 3px;
  }

  .toc-mobile-content::-webkit-scrollbar-thumb:hover {
    background: rgba(212, 183, 140, 0.5);
  }

  /* Responsive breakpoints - Chirpy style */
  @media (max-width: 1200px) {
    .toc-wrapper {
      display: none !important;
    }

    .toc-top-btn {
      display: flex !important;
    }
  }

  @media (max-width: 768px) {
    .toc-top-btn {
      top: 1rem;
      right: 1rem; /* Stay on top right */
      padding: 0.625rem 0.875rem;
      font-size: 0.8125rem;
    }

    .toc-mobile-drawer {
      max-width: 100%;
      width: 85%;
    }

    .toc-mobile-header {
      padding: 1.25rem;
    }

    .toc-mobile-close {
      width: 32px;
      height: 32px;
      font-size: 0.875rem;
      border-radius: 6px;
    }

    .toc-mobile-close svg {
      width: 18px;
      height: 18px;
    }

    .toc-mobile-content {
      padding: 1rem;
    }
  }

  @media (max-width: 480px) {
    .toc-top-btn {
      top: 1rem;
      right: 1rem; /* Stay on top right */
      padding: 0.625rem;
      min-width: 40px;
      justify-content: center;
    }

    .toc-top-btn-text {
      display: none;
    }

    .toc-top-btn svg {
      width: 20px;
      height: 20px;
    }

    .toc-mobile-drawer {
      width: 100%;
    }

    .toc-mobile-header {
      padding: 1rem;
    }

    .toc-mobile-title {
      font-size: 0.95rem;
    }

    .toc-mobile-close {
      width: 28px;
      height: 28px;
      font-size: 0.75rem;
      border-radius: 6px;
    }

    .toc-mobile-close svg {
      width: 16px;
      height: 16px;
    }
  }

  /* Glow effect for headings when navigated to */
  :global(article h2:target),
  :global(article h3:target),
  :global(.cert-content h2:target),
  :global(.cert-content h3:target),
  :global(.methodology-content h2:target),
  :global(.methodology-content h3:target) {
    animation: headingGlow 2s ease-out;
  }

  @keyframes headingGlow {
    0% {
      box-shadow: 
        0 0 20px rgba(212, 183, 140, 0.6),
        0 0 40px rgba(212, 183, 140, 0.4),
        inset 0 0 20px rgba(212, 183, 140, 0.2);
      background: rgba(212, 183, 140, 0.15);
      transform: scale(1.01);
    }
    50% {
      box-shadow: 
        0 0 30px rgba(212, 183, 140, 0.8),
        0 0 60px rgba(212, 183, 140, 0.5),
        inset 0 0 30px rgba(212, 183, 140, 0.3);
      background: rgba(212, 183, 140, 0.2);
      transform: scale(1.02);
    }
    100% {
      box-shadow: none;
      background: transparent;
      transform: scale(1);
    }
  }

  /* Active heading indicator */
  :global(h2.toc-active),
  :global(h3.toc-active),
  :global(article h2.toc-active),
  :global(article h3.toc-active),
  :global(.cert-content h2.toc-active),
  :global(.cert-content h3.toc-active),
  :global(.methodology-content h2.toc-active),
  :global(.methodology-content h3.toc-active) {
    position: relative !important;
    padding-left: 0.5rem !important;
    margin-left: -0.5rem !important;
    border-radius: 4px !important;
    background: rgba(212, 183, 140, 0.1) !important;
  }

  :global(h2.toc-active::before),
  :global(h3.toc-active::before),
  :global(article h2.toc-active::before),
  :global(article h3.toc-active::before),
  :global(.cert-content h2.toc-active::before),
  :global(.cert-content h3.toc-active::before),
  :global(.methodology-content h2.toc-active::before),
  :global(.methodology-content h3.toc-active::before) {
    content: '';
    position: absolute;
    left: -12px;
    top: 0;
    bottom: 0;
    width: 3px;
    background: var(--accent-color, #d4b78c);
    border-radius: 2px;
  }
</style>

<script>
  (function() {
    'use strict';
    
    const STORAGE_KEY = 'toc-collapsed';
    let isInitialized = false;
    let scrollTimeout: ReturnType<typeof setTimeout> | null = null;
    let rafId: number | null = null;
    let lastActiveParentId: string | null = null;
    
    // TOC collapse functionality - Chirpy exact implementation
    function initTOCCollapse() {
      const toggle = document.getElementById('toc-toggle');
      const wrapper = document.querySelector('.toc-wrapper');
      
      if (!toggle || !wrapper) return;
      
      // Get saved state from localStorage
      const savedState = localStorage.getItem(STORAGE_KEY);
      const isCollapsed = savedState === 'true';
      
      // Set initial state
      if (isCollapsed) {
        wrapper.classList.add('collapsed');
        toggle.setAttribute('aria-expanded', 'false');
      } else {
        wrapper.classList.remove('collapsed');
        toggle.setAttribute('aria-expanded', 'true');
      }
      
      // Toggle on click
      toggle.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const wasCollapsed = wrapper.classList.contains('collapsed');
        
        if (wasCollapsed) {
          wrapper.classList.remove('collapsed');
          toggle.setAttribute('aria-expanded', 'true');
          localStorage.setItem(STORAGE_KEY, 'false');
        } else {
          wrapper.classList.add('collapsed');
          toggle.setAttribute('aria-expanded', 'false');
          localStorage.setItem(STORAGE_KEY, 'true');
        }
      });
    }
    
    // Find content area
    function findContentArea() {
      const selectors = [
        'article',
        '.cert-content',
        '.methodology-content',
        '[class*="content"]',
        'main'
      ];
      
      for (const selector of selectors) {
        const element = document.querySelector(selector);
        if (element) return element;
      }
      return document.body;
    }
    
    // Build TOC - Hierarchical with folding
    function buildTOC() {
      const contentArea = findContentArea();
      if (!contentArea) return false;
      
      const headings = contentArea.querySelectorAll('h2, h3');
      const tocList = document.querySelector('.toc-list');
      const wrapper = document.querySelector('.toc-wrapper');
      
      if (!tocList || !wrapper) return false;
      
      tocList.innerHTML = '';
      
      const emptyMessage = document.getElementById('toc-empty-message');
      const mobileTocBtn = document.getElementById('toc-top-btn');
      
      if (headings.length === 0) {
        // Show empty message instead of hiding the sidebar
        (wrapper as HTMLElement).style.display = 'block';
        if (emptyMessage) {
          (emptyMessage as HTMLElement).style.display = 'block';
        }
        // Hide mobile TOC button when there are no headings
        if (mobileTocBtn) {
          (mobileTocBtn as HTMLElement).style.display = 'none';
        }
        return false;
      }
      
      // Hide empty message and show TOC
      (wrapper as HTMLElement).style.display = 'block';
      if (emptyMessage) {
        (emptyMessage as HTMLElement).style.display = 'none';
      }
      // Show mobile TOC button when there are headings
      if (mobileTocBtn) {
        (mobileTocBtn as HTMLElement).style.display = '';
      }
      
      // Group headings hierarchically with numbering
      // Filter out "last updated" headings
      const headingArray = Array.from(headings).filter((heading) => {
        const text = (heading.textContent || '').toLowerCase().trim();
        // Exclude headings that contain "last updated" or similar variations
        return !text.includes('last updated') && 
               !text.includes('last-updated') && 
               !text.includes('lastupdated') &&
               !text.match(/^last\s+updated/i);
      });
      let currentH2Item: HTMLLIElement | null = null;
      let currentSublist: HTMLUListElement | null = null;
      let h2Counter = 0;
      let h3Counter = 0;
      let currentH2Number = 0;
      
      headingArray.forEach((heading) => {
        // Ensure heading has textContent - critical for fast scrolling
        let headingText = heading.textContent || '';
        
        // If textContent is empty, try innerText or wait for it
        if (!headingText || headingText.trim() === '') {
          headingText = (heading as HTMLElement).innerText || '';
        }
        
        // If still empty, skip this heading (it might not be loaded yet)
        if (!headingText || headingText.trim() === '') {
          return;
        }
        
        if (!heading.id) {
          const id = headingText
            .toLowerCase()
            .replace(/[^\w\s-]/g, '')
            .replace(/\s+/g, '-')
            .replace(/-+/g, '-')
            .trim();
          heading.id = id || `heading-${Math.random().toString(36).substr(2, 9)}`;
        }
        
        const level = parseInt(heading.tagName.charAt(1));
        
        if (level === 2) {
          // Reset h3 counter for new h2
          h3Counter = 0;
          h2Counter++;
          currentH2Number = h2Counter;
          
          // Create new h2 item
          const li = document.createElement('li');
          li.className = 'toc-item toc-level-2';
          li.setAttribute('data-heading-id', heading.id);
          
          const a = document.createElement('a');
          a.href = `#${heading.id}`;
          a.className = 'toc-link';
          a.setAttribute('data-heading-id', heading.id);
          a.textContent = `${h2Counter} ${headingText}`;
          
          li.appendChild(a);
          tocList.appendChild(li);
          
          // Force reflow to ensure item is rendered
          void li.offsetHeight;
          
          currentH2Item = li;
          currentSublist = null;
        } else if (level === 3 && currentH2Item) {
          // Increment h3 counter for current h2
          h3Counter++;
          
          // Add h3 as child of current h2
          if (!currentSublist) {
            // Create sublist for this h2
            currentSublist = document.createElement('ul');
            currentSublist.className = 'toc-sublist';
            currentH2Item.appendChild(currentSublist);
            
            currentH2Item.classList.add('has-children');
            
            // CRITICAL: First render sublist with content visible to ensure browser calculates dimensions
            // This prevents content from not showing during fast scrolling
            currentSublist.style.maxHeight = 'none';
            currentSublist.style.opacity = '1';
            currentSublist.style.visibility = 'visible';
            
            // Force reflow to ensure sublist is fully rendered in DOM
            void currentSublist.offsetHeight;
            void currentSublist.scrollHeight;
            
            // Now collapse it after browser has rendered the content
            requestAnimationFrame(() => {
              currentH2Item!.classList.add('collapsed');
              
              // Force immediate collapse with inline styles
              currentSublist.style.maxHeight = '0';
              currentSublist.style.opacity = '0';
              currentSublist.style.visibility = 'hidden';
              currentSublist.style.marginTop = '0';
              currentSublist.style.marginBottom = '0';
              currentSublist.style.padding = '0';
              
              // Force another reflow
              void currentSublist.offsetHeight;
            });
          }
          
          // Create h3 item
          const li = document.createElement('li');
          li.className = 'toc-item toc-level-3';
          
          const a = document.createElement('a');
          a.href = `#${heading.id}`;
          a.className = 'toc-link';
          a.setAttribute('data-heading-id', heading.id);
          a.textContent = `${currentH2Number}.${h3Counter} ${headingText}`;
          
          li.appendChild(a);
          currentSublist.appendChild(li);
          
          // CRITICAL: Force multiple reflows to ensure h3 item is fully rendered
          // This is essential for fast scrolling scenarios
          void li.offsetHeight;
          void a.offsetHeight;
          void li.scrollHeight;
          void a.scrollHeight;
          
          // Force rendering of all child elements
          const allChildren = li.querySelectorAll('*');
          allChildren.forEach(child => {
            void (child as HTMLElement).offsetHeight;
            void (child as HTMLElement).scrollHeight;
          });
          
          // Force sublist to recalculate
          void currentSublist.offsetHeight;
          void currentSublist.scrollHeight;
          
          // Additional frame to ensure everything is painted
          requestAnimationFrame(() => {
            void li.offsetHeight;
            void currentSublist.offsetHeight;
          });
        }
      });
      
      // Force final reflow to ensure all content is rendered
      // This is critical when scrolling fast
      // First, temporarily show all sublists to ensure browser calculates their dimensions
      const allSublists = tocList.querySelectorAll('.toc-sublist');
      allSublists.forEach(sublist => {
        const wasCollapsed = (sublist.parentElement as HTMLElement)?.classList.contains('collapsed');
        if (wasCollapsed) {
          // Temporarily show to force rendering
          (sublist as HTMLElement).style.maxHeight = 'none';
          (sublist as HTMLElement).style.opacity = '1';
          (sublist as HTMLElement).style.visibility = 'visible';
        }
      });
      
      // Force reflow of all items
      void tocList.offsetHeight;
      const allItems = tocList.querySelectorAll('.toc-item, .toc-sublist, .toc-link');
      allItems.forEach(item => {
        void (item as HTMLElement).offsetHeight;
        void (item as HTMLElement).scrollHeight;
      });
      
      // Now restore collapsed state
      requestAnimationFrame(() => {
        allSublists.forEach(sublist => {
          const parent = sublist.parentElement as HTMLElement;
          if (parent?.classList.contains('collapsed')) {
            (sublist as HTMLElement).style.maxHeight = '0';
            (sublist as HTMLElement).style.opacity = '0';
            (sublist as HTMLElement).style.visibility = 'hidden';
            (sublist as HTMLElement).style.marginTop = '0';
            (sublist as HTMLElement).style.marginBottom = '0';
            (sublist as HTMLElement).style.padding = '0';
          }
        });
        
        void tocList.offsetHeight;
        
        // Additional frame to ensure everything is painted
        requestAnimationFrame(() => {
          void tocList.offsetHeight;
          const allH3Items = tocList.querySelectorAll('.toc-item.toc-level-3');
          allH3Items.forEach(item => {
            void (item as HTMLElement).offsetHeight;
            const link = item.querySelector('.toc-link');
            if (link) {
              void (link as HTMLElement).offsetHeight;
            }
          });
        });
      });
      
      return true;
    }
    
    // Expand section
    function expandSection(h2Item: HTMLLIElement) {
      if (h2Item.classList.contains('collapsed')) {
        const sublist = h2Item.querySelector('.toc-sublist') as HTMLElement;
        
        if (!sublist) return;
        
        // Remove collapsed class first to allow CSS to work properly
        h2Item.classList.remove('collapsed');
        
        // CRITICAL: First ensure all child items are fully rendered and visible
        // This prevents content from not showing during fast scrolling
        const childItems = sublist.querySelectorAll('.toc-item.toc-level-3');
        
        // Reset all inline styles that might prevent visibility
        sublist.style.maxHeight = '';
        sublist.style.opacity = '';
        sublist.style.visibility = '';
        sublist.style.marginTop = '';
        sublist.style.marginBottom = '';
        sublist.style.padding = '';
        sublist.style.height = '';
        
        // Reset child item styles to ensure they're visible
        childItems.forEach(item => {
          (item as HTMLElement).style.height = '';
          (item as HTMLElement).style.margin = '';
          (item as HTMLElement).style.padding = '';
          (item as HTMLElement).style.overflow = '';
          (item as HTMLElement).style.visibility = '';
          (item as HTMLElement).style.opacity = '';
          
          const link = item.querySelector('.toc-link');
          if (link) {
            (link as HTMLElement).style.display = '';
            (link as HTMLElement).style.height = '';
            (link as HTMLElement).style.visibility = '';
            (link as HTMLElement).style.opacity = '';
          }
        });
        
        // Temporarily make sublist fully visible to force browser to render all content
        sublist.style.maxHeight = 'none';
        sublist.style.opacity = '1';
        sublist.style.visibility = 'visible';
        
        // Force multiple reflows to ensure ALL content is rendered
        void sublist.offsetHeight;
        void sublist.scrollHeight;
        void h2Item.offsetHeight;
        
        // Force rendering of each child item individually
        childItems.forEach((item, index) => {
          // Reset all styles
          (item as HTMLElement).style.display = '';
          (item as HTMLElement).style.height = '';
          (item as HTMLElement).style.visibility = '';
          (item as HTMLElement).style.opacity = '';
          
          void (item as HTMLElement).offsetHeight;
          void (item as HTMLElement).scrollHeight;
          void (item as HTMLElement).offsetWidth;
          
          const link = item.querySelector('.toc-link');
          if (link) {
            (link as HTMLElement).style.display = '';
            void (link as HTMLElement).offsetHeight;
            void (link as HTMLElement).scrollHeight;
            void (link as HTMLElement).offsetWidth;
            
            // Ensure text content is rendered and visible
            const text = (link as HTMLElement).textContent;
            if (text) {
              // Force layout recalculation
              void (link as HTMLElement).offsetWidth;
              (link as HTMLElement).style.color = '';
            }
          }
          
          // Force rendering of all nested elements
          const allChildren = item.querySelectorAll('*');
          allChildren.forEach(child => {
            (child as HTMLElement).style.display = '';
            void (child as HTMLElement).offsetHeight;
            void (child as HTMLElement).scrollHeight;
          });
        });
        
        // Get the actual height after all content is rendered
        const targetHeight = sublist.scrollHeight;
        
        // Now animate from 0 to target height for smooth expansion
        requestAnimationFrame(() => {
          // Reset to 0 for animation start
          sublist.style.maxHeight = '0';
          sublist.style.opacity = '0';
          sublist.style.visibility = 'visible';
          
          // Force reflow
          void sublist.offsetHeight;
          void h2Item.offsetHeight;
          
          // Animate to full height
          requestAnimationFrame(() => {
            sublist.style.maxHeight = targetHeight + 'px';
            sublist.style.opacity = '1';
            
            // Force another reflow to ensure animation starts
            void sublist.offsetHeight;
            void h2Item.offsetHeight;
            
            // Ensure all items are visible and properly rendered during animation
            requestAnimationFrame(() => {
              childItems.forEach(item => {
                // Ensure item is visible
                (item as HTMLElement).style.display = '';
                (item as HTMLElement).style.visibility = 'visible';
                (item as HTMLElement).style.opacity = '1';
                
                void (item as HTMLElement).offsetHeight;
                void (item as HTMLElement).scrollHeight;
                
                const link = item.querySelector('.toc-link');
                if (link) {
                  (link as HTMLElement).style.display = '';
                  (link as HTMLElement).style.visibility = 'visible';
                  (link as HTMLElement).style.opacity = '1';
                  void (link as HTMLElement).offsetHeight;
                  void (link as HTMLElement).scrollHeight;
                }
              });
              
              // Final reflow to ensure everything is visible
              void sublist.offsetHeight;
              void h2Item.offsetHeight;
              
              // Clean up inline styles after animation completes (let CSS take over)
              setTimeout(() => {
                sublist.style.maxHeight = '';
                sublist.style.opacity = '';
                
                // Ensure child items remain visible
                childItems.forEach(item => {
                  (item as HTMLElement).style.display = '';
                  (item as HTMLElement).style.visibility = '';
                  (item as HTMLElement).style.opacity = '';
                  
                  const link = item.querySelector('.toc-link');
                  if (link) {
                    (link as HTMLElement).style.display = '';
                    (link as HTMLElement).style.visibility = '';
                    (link as HTMLElement).style.opacity = '';
                  }
                });
              }, 300);
            });
          });
        });
      }
    }
    
    // Collapse section
    function collapseSection(h2Item: HTMLLIElement) {
      if (!h2Item.classList.contains('collapsed')) {
        const sublist = h2Item.querySelector('.toc-sublist') as HTMLElement;
        
        if (!sublist) return;
        
        // CRITICAL: Immediately add collapsed class to apply CSS rules
        h2Item.classList.add('collapsed');
        
        // Get current height before collapsing
        const currentHeight = sublist.scrollHeight;
        
        // Set initial state for animation
        sublist.style.maxHeight = currentHeight + 'px';
        sublist.style.opacity = '1';
        sublist.style.visibility = 'visible';
        
        // Force reflow
        void sublist.offsetHeight;
        
        // Animate to 0
        requestAnimationFrame(() => {
          sublist.style.maxHeight = '0';
          sublist.style.opacity = '0';
          sublist.style.visibility = 'hidden';
          sublist.style.marginTop = '0';
          sublist.style.marginBottom = '0';
          sublist.style.padding = '0';
          
          // Force reflow to ensure browser applies the collapse
          void sublist.offsetHeight;
          void h2Item.offsetHeight;
          
          // Additional frame to ensure collapse is complete
          requestAnimationFrame(() => {
            // Force all child items to be hidden and take no space
            const childItems = sublist.querySelectorAll('.toc-item.toc-level-3');
            childItems.forEach(item => {
              (item as HTMLElement).style.height = '0';
              (item as HTMLElement).style.margin = '0';
              (item as HTMLElement).style.padding = '0';
              (item as HTMLElement).style.overflow = 'hidden';
            });
            
            // Final reflow to ensure no space is taken
            void sublist.offsetHeight;
            void h2Item.offsetHeight;
            
            // One more frame to ensure everything is collapsed
            requestAnimationFrame(() => {
              void sublist.offsetHeight;
              void h2Item.offsetHeight;
            });
          });
        });
      }
    }
    
    // Update active TOC link - Chirpy exact algorithm
    function updateActiveTOCLink() {
      const tocLinks = document.querySelectorAll('#toc .toc-link');
      if (tocLinks.length === 0) return;
      
      const contentArea = findContentArea();
      if (!contentArea) return;
      
      // Filter out "last updated" headings and headings without IDs
      const headings = Array.from(contentArea.querySelectorAll('h2, h3')).filter(h => {
        if (!h.id) return false;
        const text = (h.textContent || '').toLowerCase().trim();
        // Exclude headings that contain "last updated" or similar variations
        return !text.includes('last updated') && 
               !text.includes('last-updated') && 
               !text.includes('lastupdated') &&
               !text.match(/^last\s+updated/i);
      });
      if (headings.length === 0) return;
      
      const scrollY = window.scrollY;
      const viewportHeight = window.innerHeight;
      const offset = 100; // Offset from top
      
      let currentActive = '';
      let activeHeading: Element | null = null;
      
      // Remove all active states
      headings.forEach(h => h.classList.remove('toc-active'));
      tocLinks.forEach(link => link.classList.remove('active'));
      
      // Chirpy algorithm: find heading closest to viewport center
      let minDistance = Infinity;
      let bestHeading: Element | null = null;
      
      headings.forEach((heading) => {
        const rect = heading.getBoundingClientRect();
        const headingTop = rect.top + scrollY;
        const headingBottom = headingTop + rect.height;
        
        // Calculate distance from ideal position (offset from top)
        const distance = Math.abs(rect.top - offset);
        
        // Check if heading is in viewport and near the offset point
        if (rect.top <= offset + 100 && rect.bottom >= 0) {
          if (distance < minDistance) {
            minDistance = distance;
            bestHeading = heading;
            currentActive = heading.id;
            activeHeading = heading;
          }
        }
      });
      
      // Fallback: if no heading in active zone, find the last one we've scrolled past
      if (!currentActive && headings.length > 0) {
        for (let i = headings.length - 1; i >= 0; i--) {
          const heading = headings[i];
          const rect = heading.getBoundingClientRect();
          if (rect.top < offset + 150) {
            currentActive = heading.id;
            activeHeading = heading;
            break;
          }
        }
      }
      
      // If at top of page, use first heading
      if (!currentActive && headings.length > 0 && scrollY < 100) {
        currentActive = headings[0].id;
        activeHeading = headings[0];
      }
      
      // Apply active state to heading
      if (activeHeading && currentActive) {
        activeHeading.classList.add('toc-active');
      }
      
      // Apply active state to TOC link and handle section folding
      let currentActiveParentId: string | null = null;
      
      // First, find which parent section should be active
      tocLinks.forEach((link) => {
        const linkId = link.getAttribute('data-heading-id');
        if (linkId === currentActive && currentActive) {
          (link as HTMLElement).classList.add('active');
          
          // Find parent h2 section if this is an h3
          const h3Item = (link as HTMLElement).closest('.toc-item.toc-level-3');
          if (h3Item) {
            const parentH2 = h3Item.closest('.toc-item.toc-level-2.has-children') as HTMLLIElement;
            if (parentH2) {
              currentActiveParentId = parentH2.getAttribute('data-heading-id');
            }
          } else {
            // This is an h2, so it's its own parent
            const h2Item = (link as HTMLElement).closest('.toc-item.toc-level-2') as HTMLLIElement;
            if (h2Item) {
              currentActiveParentId = h2Item.getAttribute('data-heading-id');
            }
          }
          
          // Auto-scroll TOC to show active item
          const toc = document.getElementById('toc');
          if (toc) {
            const wrapper = toc.closest('.toc-wrapper') as HTMLElement;
            if (wrapper && !wrapper.classList.contains('collapsed')) {
              const wrapperScrollTop = wrapper.scrollTop;
              const linkOffsetTop = (link as HTMLElement).offsetTop;
              const linkHeight = (link as HTMLElement).offsetHeight;
              const wrapperHeight = wrapper.clientHeight;
              
              // Check if link is outside visible area
              if (linkOffsetTop < wrapperScrollTop || 
                  linkOffsetTop + linkHeight > wrapperScrollTop + wrapperHeight) {
                link.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
              }
            }
          }
        }
      });
      
      // CRITICAL: Collapse ALL parent sections except the currently active one
      // This ensures only the active parent has its children visible
      const allParentSections = document.querySelectorAll('.toc-item.toc-level-2.has-children') as NodeListOf<HTMLLIElement>;
      allParentSections.forEach((parentSection) => {
        const parentId = parentSection.getAttribute('data-heading-id');
        
        if (parentId === currentActiveParentId) {
          // This is the active parent - expand it
          expandSection(parentSection);
        } else {
          // This is NOT the active parent - collapse it immediately
          // Force immediate collapse to prevent visual artifacts during fast scrolling
          if (!parentSection.classList.contains('collapsed')) {
            collapseSection(parentSection);
          } else {
            // Even if already collapsed, ensure it's fully collapsed (no space)
            const sublist = parentSection.querySelector('.toc-sublist') as HTMLElement;
            if (sublist) {
              // Force immediate collapse with no space
              sublist.style.maxHeight = '0';
              sublist.style.opacity = '0';
              sublist.style.visibility = 'hidden';
              sublist.style.marginTop = '0';
              sublist.style.marginBottom = '0';
              sublist.style.padding = '0';
              sublist.style.height = '0';
              
              // Force child items to take no space
              const childItems = sublist.querySelectorAll('.toc-item.toc-level-3');
              childItems.forEach(item => {
                (item as HTMLElement).style.height = '0';
                (item as HTMLElement).style.margin = '0';
                (item as HTMLElement).style.padding = '0';
              });
              
              // Force reflow
              void sublist.offsetHeight;
              void parentSection.offsetHeight;
            }
          }
        }
      });
      
      lastActiveParentId = currentActiveParentId;
    }
    
    // TOC link click handler
    function handleTOCClick(e: Event) {
      const tocLink = (e.target as HTMLElement).closest('.toc-link');
      if (!tocLink) return;
      
      e.preventDefault();
      const href = tocLink.getAttribute('href');
      if (!href || !href.startsWith('#')) return;
      
      const target = document.querySelector(href);
      if (!target) return;
      
      const targetId = href.substring(1);
      const contentArea = findContentArea();
      
      // Immediately set active state
      if (contentArea) {
        // Filter out "last updated" headings and headings without IDs
        const headings = Array.from(contentArea.querySelectorAll('h2, h3')).filter(h => {
          if (!h.id) return false;
          const text = (h.textContent || '').toLowerCase().trim();
          // Exclude headings that contain "last updated" or similar variations
          return !text.includes('last updated') && 
                 !text.includes('last-updated') && 
                 !text.includes('lastupdated') &&
                 !text.match(/^last\s+updated/i);
        });
        headings.forEach(h => h.classList.remove('toc-active'));
        const targetHeading = headings.find(h => h.id === targetId);
        if (targetHeading) {
          targetHeading.classList.add('toc-active');
          
          // Find which parent section should be active
          let activeParentId: string | null = null;
          
          if (targetHeading.tagName === 'H3') {
            const h3Item = tocLink.closest('.toc-item.toc-level-3');
            if (h3Item) {
              const parentH2 = h3Item.closest('.toc-item.toc-level-2.has-children') as HTMLLIElement;
              if (parentH2) {
                activeParentId = parentH2.getAttribute('data-heading-id');
              }
            }
          } else if (targetHeading.tagName === 'H2') {
            const h2Item = tocLink.closest('.toc-item.toc-level-2') as HTMLLIElement;
            if (h2Item) {
              activeParentId = h2Item.getAttribute('data-heading-id');
            }
          }
          
          // Collapse ALL parent sections except the active one
          const allParentSections = document.querySelectorAll('.toc-item.toc-level-2.has-children') as NodeListOf<HTMLLIElement>;
          allParentSections.forEach((parentSection) => {
            const parentId = parentSection.getAttribute('data-heading-id');
            
            if (parentId === activeParentId) {
              // This is the active parent - expand it
              expandSection(parentSection);
            } else {
              // This is NOT the active parent - collapse it
              if (!parentSection.classList.contains('collapsed')) {
                collapseSection(parentSection);
              }
            }
          });
        }
      }
      
      // Close mobile TOC drawer if open
      const mobileOverlay = document.getElementById('toc-mobile-overlay');
      if (mobileOverlay && mobileOverlay.classList.contains('active')) {
        mobileOverlay.classList.remove('active');
        document.body.style.overflow = '';
      }
      
      // Scroll to target
      const offset = 100;
      const targetPosition = target.getBoundingClientRect().top + window.pageYOffset - offset;
      window.scrollTo({
        top: targetPosition,
        behavior: 'smooth'
      });
      
      // Update active state after scroll
      const updateTimes = [100, 200, 400, 600, 800, 1000];
      updateTimes.forEach((delay) => {
        setTimeout(() => {
          updateActiveTOCLink();
        }, delay);
      });
    }
    
    // Mobile TOC functionality - Chirpy style
    function initMobileTOC() {
      const topBtn = document.getElementById('toc-top-btn');
      const mobileOverlay = document.getElementById('toc-mobile-overlay');
      const mobileClose = document.getElementById('toc-mobile-close');
      const mobileContent = document.getElementById('toc-mobile-content');
      const desktopTocList = document.querySelector('#toc .toc-list');
      
      if (!mobileOverlay || !mobileClose || !mobileContent) return;
      
      // Sync TOC list to mobile drawer
      function syncTOCList() {
        if (desktopTocList && mobileContent) {
          const mobileTocList = mobileContent.querySelector('.toc-list');
          if (mobileTocList) {
            mobileTocList.innerHTML = desktopTocList.innerHTML;
            // Re-attach click handlers to mobile TOC links
            const mobileLinks = mobileTocList.querySelectorAll('.toc-link');
            mobileLinks.forEach(link => {
              link.addEventListener('click', (e) => {
                const href = link.getAttribute('href');
                if (href && href.startsWith('#')) {
                  // Close mobile drawer after clicking
                  setTimeout(() => {
                    closeMobileTOC();
                  }, 100);
                }
              });
            });
          } else {
            const newList = desktopTocList.cloneNode(true) as HTMLElement;
            mobileContent.innerHTML = '';
            mobileContent.appendChild(newList);
            // Attach click handlers
            const mobileLinks = newList.querySelectorAll('.toc-link');
            mobileLinks.forEach(link => {
              link.addEventListener('click', (e) => {
                const href = link.getAttribute('href');
                if (href && href.startsWith('#')) {
                  setTimeout(() => {
                    closeMobileTOC();
                  }, 100);
                }
              });
            });
          }
        }
      }
      
      // Open mobile TOC
      function openMobileTOC() {
        if (!mobileOverlay) return;
        
        // Ensure overlay is visible
        mobileOverlay.style.display = 'block';
        
        // Sync TOC list first
        syncTOCList();
        
        // Force reflow to ensure display is set
        void mobileOverlay.offsetHeight;
        
        // Then add active class for animation
        requestAnimationFrame(() => {
          mobileOverlay.classList.add('active');
          document.body.style.overflow = 'hidden';
        });
      }
      
      // Close mobile TOC
      function closeMobileTOC() {
        if (!mobileOverlay) return;
        mobileOverlay.classList.remove('active');
        document.body.style.overflow = '';
        
        // Hide overlay after animation
        setTimeout(() => {
          if (!mobileOverlay.classList.contains('active')) {
            mobileOverlay.style.display = 'none';
          }
        }, 300);
      }
      
      // Event listener for top button
      if (topBtn) {
        topBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          openMobileTOC();
        });
      }
      
      mobileClose.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeMobileTOC();
      });
      
      // Close on overlay click
      mobileOverlay.addEventListener('click', (e) => {
        if (e.target === mobileOverlay) {
          closeMobileTOC();
        }
      });
      
      // Close on ESC key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && mobileOverlay.classList.contains('active')) {
          closeMobileTOC();
        }
      });
      
      // Sync TOC when it's built
      const observer = new MutationObserver(() => {
        if (desktopTocList && desktopTocList.children.length > 0) {
          syncTOCList();
        }
      });
      
      if (desktopTocList) {
        observer.observe(desktopTocList, { childList: true, subtree: true });
      }
    }

    // Initialize TOC
    function initializeTOC() {
      const success = buildTOC();
      if (success) {
        initTOCCollapse();
        initMobileTOC();
        requestAnimationFrame(() => {
          updateActiveTOCLink();
        });
        setTimeout(() => {
          updateActiveTOCLink();
        }, 100);
        isInitialized = true;
      }
      return success;
    }
    
    // Initialize with retries
    function initWithRetries() {
      if (initializeTOC()) return;
      
      const retries = [50, 100, 200, 500, 1000, 2000];
      retries.forEach((delay) => {
        setTimeout(() => {
          if (!isInitialized) {
            initializeTOC();
          }
        }, delay);
      });
    }
    
    // Initialize on load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initWithRetries();
      });
    } else {
      initWithRetries();
    }
    
    // Handle Astro view transitions
    const handlePageLoad = () => {
      isInitialized = false;
      lastActiveParentId = null;
      setTimeout(() => {
        initWithRetries();
      }, 50);
    };
    
    document.addEventListener('astro:page-load', handlePageLoad);
    document.addEventListener('astro:after-swap', handlePageLoad);
    document.addEventListener('astro:before-swap', () => {
      isInitialized = false;
      lastActiveParentId = null;
    });
    
    // Handle navigation
    window.addEventListener('pageshow', () => {
      isInitialized = false;
      setTimeout(() => {
        initWithRetries();
      }, 50);
    });
    
    window.addEventListener('popstate', () => {
      isInitialized = false;
      setTimeout(() => {
        initWithRetries();
      }, 100);
    });
    
    // Handle hash changes
    window.addEventListener('hashchange', () => {
      const hash = window.location.hash.substring(1);
      if (hash) {
        const contentArea = findContentArea();
        if (contentArea) {
          // Filter out "last updated" headings and headings without IDs
          const headings = Array.from(contentArea.querySelectorAll('h2, h3')).filter(h => {
            if (!h.id) return false;
            const text = (h.textContent || '').toLowerCase().trim();
            // Exclude headings that contain "last updated" or similar variations
            return !text.includes('last updated') && 
                   !text.includes('last-updated') && 
                   !text.includes('lastupdated') &&
                   !text.match(/^last\s+updated/i);
          });
          headings.forEach(h => h.classList.remove('toc-active'));
          const targetHeading = headings.find(h => h.id === hash);
          if (targetHeading) {
            targetHeading.classList.add('toc-active');
          }
        }
      }
      setTimeout(() => {
        updateActiveTOCLink();
      }, 100);
    });
    
    // Handle initial hash
    function handleInitialHash() {
      const hash = window.location.hash.substring(1);
      if (hash) {
        setTimeout(() => {
          const contentArea = findContentArea();
          if (contentArea) {
            // Filter out "last updated" headings and headings without IDs
            const headings = Array.from(contentArea.querySelectorAll('h2, h3')).filter(h => {
              if (!h.id) return false;
              const text = (h.textContent || '').toLowerCase().trim();
              // Exclude headings that contain "last updated" or similar variations
              return !text.includes('last updated') && 
                     !text.includes('last-updated') && 
                     !text.includes('lastupdated') &&
                     !text.match(/^last\s+updated/i);
            });
            const targetHeading = headings.find(h => h.id === hash);
            if (targetHeading) {
              targetHeading.classList.add('toc-active');
            }
          }
          updateActiveTOCLink();
        }, 300);
      }
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', handleInitialHash);
    } else {
      handleInitialHash();
    }
    
    // Handle direct anchor clicks in content
    document.addEventListener('click', (e) => {
      const anchor = (e.target as HTMLElement).closest('a[href^="#"]');
      if (anchor && anchor.getAttribute('href') !== '#' && !anchor.classList.contains('toc-link')) {
        const href = anchor.getAttribute('href');
        if (href) {
          const targetId = href.substring(1);
          const contentArea = findContentArea();
          if (contentArea) {
            // Filter out "last updated" headings and headings without IDs
            const headings = Array.from(contentArea.querySelectorAll('h2, h3')).filter(h => {
              if (!h.id) return false;
              const text = (h.textContent || '').toLowerCase().trim();
              // Exclude headings that contain "last updated" or similar variations
              return !text.includes('last updated') && 
                     !text.includes('last-updated') && 
                     !text.includes('lastupdated') &&
                     !text.match(/^last\s+updated/i);
            });
            headings.forEach(h => h.classList.remove('toc-active'));
            const targetHeading = headings.find(h => h.id === targetId);
            if (targetHeading) {
              targetHeading.classList.add('toc-active');
            }
          }
          setTimeout(() => {
            updateActiveTOCLink();
          }, 200);
        }
      }
    });
    
    // Watch for content changes
    const observer = new MutationObserver(() => {
      if (!isInitialized) {
        setTimeout(() => {
          initializeTOC();
        }, 100);
      }
    });
    
    if (document.body) {
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
    
    // TOC click handler
    document.addEventListener('click', handleTOCClick);
    
    // Scroll handler with requestAnimationFrame - Chirpy style
    // Also ensures TOC content is rendered during fast scrolling
    let lastScrollTime = 0;
    window.addEventListener('scroll', () => {
      const now = Date.now();
      const timeSinceLastScroll = now - lastScrollTime;
      lastScrollTime = now;
      
      // During fast scrolling, ensure TOC sublist content is rendered
      if (timeSinceLastScroll < 16 || timeSinceLastScroll > 100) {
        requestAnimationFrame(() => {
          // Force rendering of all visible TOC items
          const allSublists = document.querySelectorAll('.toc-sublist');
          const allH3Items = document.querySelectorAll('.toc-item.toc-level-3');
          
          allSublists.forEach(sublist => {
            const rect = (sublist as HTMLElement).getBoundingClientRect();
            // Only process if element is in or near viewport
            if (rect.top < window.innerHeight + 200 && rect.bottom > -200) {
              void (sublist as HTMLElement).offsetHeight;
              const children = sublist.querySelectorAll('*');
              children.forEach(child => void (child as HTMLElement).offsetHeight);
            }
          });
          
          allH3Items.forEach(item => {
            const rect = (item as HTMLElement).getBoundingClientRect();
            if (rect.top < window.innerHeight + 200 && rect.bottom > -200) {
              void (item as HTMLElement).offsetHeight;
              const link = item.querySelector('.toc-link');
              if (link) {
                void (link as HTMLElement).offsetHeight;
              }
            }
          });
        });
      }
      
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
      }
      
      rafId = requestAnimationFrame(() => {
        updateActiveTOCLink();
        rafId = null;
      });
      
      if (scrollTimeout) clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        updateActiveTOCLink();
      }, 50);
    }, { passive: true });
    
    // Periodic check
    let checkCount = 0;
    const maxChecks = 10;
    const checkInterval = setInterval(() => {
      if (checkCount < maxChecks) {
        if (!isInitialized) {
          initializeTOC();
        } else {
          updateActiveTOCLink();
        }
        checkCount++;
      } else {
        clearInterval(checkInterval);
      }
    }, 300);
    
    // Initial updates
    setTimeout(() => {
      updateActiveTOCLink();
    }, 500);
    setTimeout(() => {
      updateActiveTOCLink();
    }, 1000);
  })();
</script>
